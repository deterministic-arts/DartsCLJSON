DartsCLJSON
===========

This library provides basic functions to read/parse JSON encoded data,
as well as stuff to generate properly formatted JSON representations of
objects. Unlike CL-JSON, this library provides mostly low-level stuff.
In particular, this library does not include a serialization layer for
arbitrary objects (though one could be added, using what is provided 
here as the building blocks)

One feature not found in other JSON-handling libraries AFAICT is the
optional push-parser support, which allows for "event-driven" parsing
of JSON encoded data (i.e., incrementally parse parts of the object
tree as soon as input bytes become available and get notified via 
callback, when a complete object has been consumed).

Pattern Matching
-----------------

The library provides a simple pattern matching facility over the kind
of tree structures generated by the pull and push parsers. The following
macros are defined

 - *Macro* `if-json-bind` _pattern_ _form_ _then_ _else_ &rarr; _values_
 
   Evaluates _form_ and tries to match the result against the given _pattern_, 
   binding components to pattern variables during the process. If the 
   match is successful, evaluates _then_ in a context, where all variables
   are bound. If matching fails, evaluates _else_ without any pattern
   variables bound. Returns the values produced by _then_ or _else_ (whichever
   was evaluated after matching.)
   
 - *Macro* `when-json-bind` _pattern_ _form_ `&body` _body_ &rarr; _values_
 
   Evaluates _form_ and tries to match the result against the given _pattern_,
   binding components to pattern variables during the process. If the
   match is successful, evaluates the given _body_ forms like an implicit
   `progn`, returning the _values_ produced by the last body form. If 
   matching fails, the `when-json-bind` form returns `nil`.
   
 - *Macro* `json-match` _form_ `&body` _clauses_ &rarr; _values_
 
   Where each of the _clauses_ has the structure (_pattern_ _body1_ ...). Evaluates 
   _form_ and tries to match it against the pattern part of each clause
   in _clauses_ in the order they are specified. If the match is successful,
   evaluates the associated _bodyK_ forms in a context, in which the pattern
   variables are bound. Returns the value(s) produced by the last evaluated
   body form. If no pattern matches, returns `nil`.

 - *Macro* `json-ematch` _form_ `&body` _clauses_ &rarr; _values_
 
   Where each of the _clauses_ has the structure (_pattern_ _body1_ ...). Evaluates 
   _form_ and tries to match it against the pattern part of each clause
   in _clauses_ in the order they are specified. If the match is successful,
   evaluates the associated _bodyK_ forms in a context, in which the pattern
   variables are bound. Returns the value(s) produced by the last evaluated
   body form. If no pattern matches, signals an error.

A pattern (as used in the description above) is one of

  - `(:any VAR)` matches anything, causing `VAR` to be bound to the matching object
  - `(:string VAR)` matches a string, binding `VAR`
  - `(:number VAR)` matches a number, binding `VAR`
  - `(:boolean VAR)` matches a (JSON) boolean (:true, :false), binding `VAR`
  - `(:null VAR)` matches the (JSON) null value :null, binding `VAR`
  - `(:array [REQUIRED ...] [&optional OPTIONAL ...] [&rest REST] [&whole WHOLE])`
 
    Matches a (JSON) array. Each entry of `REQUIRED` and `OPTIONAL` may be another 
    pattern. If no `REST` argument is supplied, an `:array` pattern matches only
    arrays of certain lengths (i.e., `(<= (length REQUIRED) (length ARRAY) (+ (length REQUIRED) (length OPTIONAL)))`)
    otherwise, the `REST` argument will "soak up" excess elements. If a `WHOLE`
    variable is supplied, the full matching object is bound to that name.
      
  - `(:object [REQUIRED ...] [&optional OPTIONAL ...] [&rest REST] [&whole WHOLE])`

    Matches a (JSON) array. Each entry of `REQUIRED` and `OPTIONAL` may be a
    "field specification" of the form
    
    > `(KEY PATTERN)` 
    
    where `KEY` is a symbol or a string, and `PATTERN` is a sub-pattern, that
    must be satisfied. The abbreviation
    
    > `VAR` 
    
    is short for `(VAR (:any VAR))`; the `VAR` cannot be `_` in this case . 
    The match succeeds, if at least all the fields in the `REQUIRED` section are 
    present, and if the fields in the `OPTIONAL` section match. If `REST` is specified, 
    its value will be a plist of additional key/value pairs for object fields, which 
    were neither listed in the required nor in the optional section. If no rest section is
    specified, a match will fail if the object contains unknown fields. If a `WHOLE`
    variable is supplied, the full matching object is bound to that name.

In all of the pattern kinds above, if a variable is named "_" (regardless of
its home package), then the matching value is not bound to a variable at all;
the associated constraint is checked, though. 

Patterns can be abbreviated as follows, if no variables need to be bound:

 - `:any` is equivalent to `(:any _)`
 - `:string` is equivalent to `(:string _)`
 - `:number` is equivalent to `(:number _)`
 - `:boolean` is equivalent to `(:boolean _)`
 - `:null` is equivalent to `(:null _)`
 - `:array` is equivalent to `(:array &rest _)`
 - `:object` is equivalent to `(:object &rest _)`

Examples:

    (if-json-bind (:object identifier &rest properties) '(:object "name" "dummy" "identifier" 17)
      (assert (equal identifier 17))
      (error "Hu. That should have matched"))

    (json-match '(:array 1 2 3 4)
      ((:array &optional _) (print (list 'at-most-one)))
      ((:array _ _ x &rest _) (print (list 'at-least-three x))))
