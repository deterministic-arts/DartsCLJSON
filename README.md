# DartsCLJSON

This library provides basic functions to read/parse JSON encoded data,
as well as stuff to generate properly formatted JSON representations of
objects. Unlike CL-JSON, this library provides mostly low-level stuff.
In particular, this library does not include a serialization layer for
arbitrary objects (though one could be added, using what is provided 
here as the building blocks)

One feature not found in other JSON-handling libraries AFAICT is the
optional push-parser support, which allows for "event-driven" parsing
of JSON encoded data (i.e., incrementally parse parts of the object
tree as soon as input bytes become available and get notified via 
callback, when a complete object has been consumed).

## Parsing

The library provides two parsers for JSON encoded data. A "traditional"
stream-based pull parser as well as a push-style parser.

 - *Condition* `json-parse-error` 
 
   Class precedence list `json-parse-error`, `error`, `serious-condition`, `condition`
 
   Signalled by both parser types, if the input is not a syntactically
   well-formed JSON object.
   
 - *Condition* `simple-json-parse-error` 
 
   Class precedence list `simple-json-parse-error`, `simple-condition`,  `json-parse-error`, `error`, `serious-condition`, `condition`

 - *Function* `read-json-value` _stream_ &rarr; _value_
 
   Reads the next full JSON encoded value from _stream_ and returns
   it. If the end of the stream is reached before the beginning of a
   value is seen, returns `nil`.
   
   The _value_ will be one of
   
    - `nil` if the end of the input stream is reached
    - `:null` for the JSON value `null`
    - `:true` for the JSON boolean value `true`
    - `:false` for the JSON boolean value `false`
    - a string for a JSON string
    - a number for a JSON number
    - a list of the form `(:array elt1 elt2 ...)` for a JSON array
      of the form `[elt1, elt2, ...]`
    - a list of the form `(:object key1 val1 key2 val2 ...)` for a
      JSON object of the form `{key1: val1, key2: val2, ...}`
      
   This function expects _stream_ to be a character-based input
   stream.
   
 - *Function* `make-json-push-parser` _callback_ `&key` _byte-input_ &rarr; _parser_
 
   Constructs a new push parser function and returns it. If _byte-input_
   is false (the default) the parser expects to be fed characters,
   otherwise it must be fed with bytes (which are interpreted as 
   stream of UTF-8 encoded characters.)
   
   The _parser_ is a function `(lambda (buffer &optional (start 0) end) ...)`
   which should be called with partial input sequences. Whenever a 
   complete JSON value has been assembled, it invokes _callback_,
   passing the recognized object as (only) argument. The push parser
   constructs the same kind of objects for its input as the pull parser
   does.
   
   Note that the parser is greedy, i.e.,
   
       (let ((parser (make-json-push-parser #'print)))
         (funcall parser "12")
         (funcall parser "34")
         (funcall parser nil))
         
   prints `1234`, not the two number `12` followed by `34`. Also note,
   that you have to explicitly specify the end of the input stream by
   calling the parser with a `nil` argument, since it may hold partially
   processed input characters internally.

### Auxiliary Functions And Macros

 - *Function* `read-json-token` _stream_ &rarr; _value_
 - *Function* `read-json-value-from-string` _string_ `&optional` (_start_ 0) _end_ &rarr; _value_
   
## Generating JSON

### High-Level

 - *Function* `write-json-null`
 - *Function* `write-json-number` _value_
 - *Function* `write-json-boolean` _value_
 - *Function* `write-json-string` _value_ `&key` _start_ _end_
 - *Function* `write-json-key` _value_ `&key` _start_ _end_
 - *Macro* `writing-json-array` `&body` _body_
 - *Macro* `writing-json-object` `&body` _body_
 - *Macro* `with-json-output-context` `(` _stream_ `&key` _ascii-only_ _dense-output_ `)` `&body` _body_ 

### Low-Level 

 - *Function* `render-json-null` _stream_ &rarr; _nil_
 - *Function* `render-json-boolean` _value_ _stream_ &rarr; _value_
 - *Function* `render-json-number` _value_ _stream_ &rarr; _value_
 - *Function* `render-json-string` _value_ _stream_ `&key` _start_ _end_ _ascii-only_ &rarr; _value_
 - *Function* `render-json-array-start` _stream_ `&key` _dense-output_ &rarr; _nil_
 - *Function* `render-json-array-end` _stream_ `&key` _dense-output_ &rarr; _nil_
 - *Function* `render-json-object-start` _stream_ `&key` _dense-output_ &rarr; _nil_
 - *Function* `render-json-object-end` _stream_ `&key` _dense-output_ &rarr; _nil_
 - *Function* `render-json-key` _value_ _stream_ `&key` _start_ _end_ _ascii-only_ _dense-outut_ &rarr; _value_
 
## Pattern Matching

The library provides a simple pattern matching facility over the kind
of tree structures generated by the pull and push parsers. The following
macros are defined

 - *Macro* `if-json-bind` _pattern_ _form_ _then_ _else_ &rarr; _values_
 
   Evaluates _form_ and tries to match the result against the given _pattern_, 
   binding components to pattern variables during the process. If the 
   match is successful, evaluates _then_ in a context, where all variables
   are bound. If matching fails, evaluates _else_ without any pattern
   variables bound. Returns the values produced by _then_ or _else_ (whichever
   was evaluated after matching.)
   
 - *Macro* `when-json-bind` _pattern_ _form_ `&body` _body_ &rarr; _values_
 
   Evaluates _form_ and tries to match the result against the given _pattern_,
   binding components to pattern variables during the process. If the
   match is successful, evaluates the given _body_ forms like an implicit
   `progn`, returning the _values_ produced by the last body form. If 
   matching fails, the `when-json-bind` form returns `nil`.
   
 - *Macro* `json-match` _form_ `&body` _clauses_ &rarr; _values_
 
   Where each of the _clauses_ has the structure (_pattern_ _body1_ ...). Evaluates 
   _form_ and tries to match it against the pattern part of each clause
   in _clauses_ in the order they are specified. If the match is successful,
   evaluates the associated _bodyK_ forms in a context, in which the pattern
   variables are bound. Returns the value(s) produced by the last evaluated
   body form. If no pattern matches, returns `nil`.

 - *Macro* `json-ematch` _form_ `&body` _clauses_ &rarr; _values_
 
   Where each of the _clauses_ has the structure (_pattern_ _body1_ ...). Evaluates 
   _form_ and tries to match it against the pattern part of each clause
   in _clauses_ in the order they are specified. If the match is successful,
   evaluates the associated _bodyK_ forms in a context, in which the pattern
   variables are bound. Returns the value(s) produced by the last evaluated
   body form. If no pattern matches, signals an error.

A pattern (as used in the description above) is one of

  - a string matches any `equal` string
  - a number matches any `equal` number
  - `:true` matches exactly the `:true` keyword
  - `:false` matches exactly the `:false` keyword
  - `:null` matches exactly the `:null` keyword
  - `(:any VAR)` matches anything, causing `VAR` to be bound to the matching object
  - `(:string VAR)` matches a string, binding `VAR`
  - `(:number VAR)` matches a number, binding `VAR`
  - `(:boolean VAR)` matches a (JSON) boolean (:true, :false), binding `VAR`
  - `(:array [REQUIRED ...] [&optional OPTIONAL ...] [&rest REST] [&whole WHOLE])`
 
    Matches a (JSON) array. Each entry of `REQUIRED` and `OPTIONAL` may be another 
    pattern. If no `REST` argument is supplied, an `:array` pattern matches only
    arrays of certain lengths (i.e., `(<= (length REQUIRED) (length ARRAY) (+ (length REQUIRED) (length OPTIONAL)))`)
    otherwise, the `REST` argument will "soak up" excess elements. If a `WHOLE`
    variable is supplied, the full matching object is bound to that name.
      
  - `(:object [REQUIRED ...] [&optional OPTIONAL ...] [&rest REST] [&whole WHOLE])`

    Matches a (JSON) array. Each entry of `REQUIRED` and `OPTIONAL` may be a
    "field specification" of the form
    
    > `(KEY PATTERN)` 
    
    where `KEY` is a symbol or a string, and `PATTERN` is a sub-pattern, that
    must be satisfied. The abbreviation
    
    > `VAR` 
    
    is short for `(VAR (:any VAR))`; the `VAR` cannot be `_` in this case. If
    the key is derived from a symbol, the key string is an all-lower-case version
    of the symbol's print names, with hyphens `-` replaced by underscores `_`.
    
    The match succeeds, if at least all the fields in the `REQUIRED` section are 
    present, and if the fields in the `OPTIONAL` section match. If `REST` is specified, 
    its value will be a plist of additional key/value pairs for object fields, which 
    were neither listed in the required nor in the optional section. If no rest section is
    specified, a match will fail if the object contains unknown fields. If a `WHOLE`
    variable is supplied, the full matching object is bound to that name.

In all of the pattern kinds above, if a variable is named "_" (regardless of
its home package), then the matching value is not bound to a variable at all;
the associated constraint is checked, though. Any symbol can be used as pattern
variable, provided it is not a keyword, and not `nil` or `t`. The effects are
undefined, if a given pattern includes the same pattern variable multiple times
(either directly, or as part of one or more sub-patterns.)

Patterns can be abbreviated as follows, if no variables need to be bound:

 - `VAR` is equivalent to `(:any VAR)`; in particular, `_` is equivent to `(:any _)`,
   which matches any input and binds nothing
 - `:any` is equivalent to `(:any _)`
 - `:string` is equivalent to `(:string _)`
 - `:number` is equivalent to `(:number _)`
 - `:boolean` is equivalent to `(:boolean _)`
 - `:array` is equivalent to `(:array &rest _)`
 - `:object` is equivalent to `(:object &rest _)`

Examples:

    (if-json-bind (:object identifier &rest properties) '(:object "name" "dummy" "identifier" 17)
      (assert (equal identifier 17))
      (error "Hu. That should have matched"))

    (json-match '(:array 1 2 3 4)
      ((:array &optional _) (print (list 'at-most-one)))
      ((:array _ _ x &rest _) (print (list 'at-least-three x))))
      
    (json-match '(:object "type" "response" "identifier" "1" "result" (:object))
      ((:object ("type" "command") ("command" (:string command)) ("identifier" (:string identifier)) &optional ("argument" (:object &rest _ &whole object)))
       (print (list 'command command identifier argument)))
      ((:object ("type" "response") ("identifier" (:string identifier)) &optional ("result" (:object &rest _ &whole result)))
       (print (list 'response identifier result)))
      ((:object ("type" "failure") ("identifier" (:string identifier)) ("code" (:string code)) &optional ("detail" (:object &rest _ &whole detail)))
       (print (list 'failure identifier code detail)))
      (invalid (error "bad message ~S" invalid)))
